<!DOCTYPE html><html lang="en" data-theme="light"><head><head> <!-- Include Meta Tags Here --><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta http-equiv="X-UA-Compatible" content="ie=edge"><meta content='#000000' name='theme-color'/><meta name="keywords" content="Site, Template, Theme"><title>Solais Security Solutions | Commit Signing - Is it worth it?</title><link rel="canonical" href="https://solaissecurity.com/blog/commit-signing-overview"> <!-- Open Graph general (Facebook, Pinterest & Google+) --><meta property="og:title" content="Solais Security Solutions | Commit Signing - Is it worth it?"><meta property="og:description" content="Deep dive into why commit signing is worth it, even when hosted platforms like GitHub have strong authentication controls."><meta property="og:image" content="https://solaissecurity.com/assets/images/blog/anonymous-commits.png"><meta property="og:image:alt" content="Solais Security Solutions | Commit Signing - Is it worth it?"><meta property="og:url" content="https://solaissecurity.com/blog/commit-signing-overview"><meta property="og:site_name" content="Solais Security Solutions"><meta property="og:type" content="article"> <!-- Twitter --><meta name="twitter:card" content="summary_large_image"><meta name="twitter:title" content="Solais Security Solutions | Commit Signing - Is it worth it?"><meta name="twitter:description" content="Deep dive into why commit signing is worth it, even when hosted platforms like GitHub have strong authentication controls."><meta name="twitter:image" content="https://solaissecurity.com/assets/images/blog/anonymous-commits.png"> <!-- Search Engine --><meta name="description" content="Deep dive into why commit signing is worth it, even when hosted platforms like GitHub have strong authentication controls."><meta name="image" content="https://solaissecurity.com/assets/images/blog/anonymous-commits.png"> <!-- Schema.org for Google --><meta itemprop="name" content="Solais Security Solutions | Commit Signing - Is it worth it?"><meta name="author" content="Kevin Quill"><meta itemprop="description" content="Deep dive into why commit signing is worth it, even when hosted platforms like GitHub have strong authentication controls."><meta itemprop="image" content="https://solaissecurity.com/assets/images/blog/anonymous-commits.png"><title>Solais Security Solutions</title><link rel="stylesheet" href="/assets/css/style.css"> <script src="https://kit.fontawesome.com/f5a7c7110b.js" crossorigin="anonymous"></script> <!--<link rel="shortcut icon" href="' | absolute_url }}" type="image/x-icon"> --> <!-- Favicon: default / light mode --><link rel="icon" type="image/png" sizes="16x16" href="https://solaissecurity.com/assets/images/favicons/light-favicon-16.png?v=3"><link rel="icon" type="image/png" sizes="32x32" href="https://solaissecurity.com/assets/images/favicons/light-favicon-32.png?v=3"><link rel="icon" type="image/png" sizes="48x48" href="https://solaissecurity.com/assets/images/favicons/light-favicon-48.png?v=3"><link rel="icon" type="image/png" sizes="96x96" href="https://solaissecurity.com/assets/images/favicons/light-favicon-96.png?v=3"><link rel="icon" type="image/png" sizes="192x192" href="https://solaissecurity.com/assets/images/favicons/light-favicon-192.png?v=3"><link rel="icon" type="image/png" sizes="512x512" href="https://solaissecurity.com/assets/images/favicons/light-favicon-512.png?v=3"><link rel="shortcut icon" href="https://solaissecurity.com/assets/images/favicons/light-favicon.ico?v=3"> <!-- Apple Touch Icon --><link rel="apple-touch-icon" sizes="180x180" href="https://solaissecurity.com/assets/images/favicons/dark-apple-touch-icon.png?v=3"> <!-- Dark mode icons --><link rel="icon" type="image/png" sizes="16x16" href="https://solaissecurity.com/assets/images/favicons/dark-favicon-16.png?v=3" media="(prefers-color-scheme: dark)"><link rel="icon" type="image/png" sizes="32x32" href="https://solaissecurity.com/assets/images/favicons/dark-favicon-32.png?v=3" media="(prefers-color-scheme: dark)"><link rel="icon" type="image/png" sizes="48x48" href="https://solaissecurity.com/assets/images/favicons/dark-favicon-48.png?v=3" media="(prefers-color-scheme: dark)"><link rel="icon" type="image/png" sizes="96x96" href="https://solaissecurity.com/assets/images/favicons/dark-favicon-96.png?v=3" media="(prefers-color-scheme: dark)"><link rel="icon" type="image/png" sizes="192x192" href="https://solaissecurity.com/assets/images/favicons/dark-favicon-192.png?v=3" media="(prefers-color-scheme: dark)"><link rel="icon" type="image/png" sizes="512x512" href="https://solaissecurity.com/assets/images/favicons/dark-favicon-512.png?v=3" media="(prefers-color-scheme: dark)"><link rel="shortcut icon" href="https://solaissecurity.com/assets/images/favicons/dark-favicon.ico?v=3" media="(prefers-color-scheme: dark)"> <!-- Optional: Safari / iOS prefers Apple Touch Icon automatically --><link rel="apple-touch-icon" sizes="180x180" href="https://solaissecurity.com/assets/images/favicons/light-apple-touch-icon.png?v=3" media="(prefers-color-scheme: light)"><meta name="google-site-verification" content="fQzaBNUGPJYJiCBtHtchqgSngH3hglzEB_7QcNLeNBE" /> <script src="https://cdn.counter.dev/script.js" data-id="16e4d60c-cadd-4633-9289-e43d0d61fa63" data-utcoffset="0"></script> <script src="/assets/js/navbar.js"></script></head></head><body><nav class="navbar is-primary is-fixed-top" role="navigation" aria-label="main navigation" data-theme="dark" id="navbar"> <!-- logo or branding image on left side --><div class="navbar-brand"> <a class="navbar-item" href="https://solaissecurity.com/"> <img src="https://solaissecurity.com/assets/images/header_logo.png" alt="Logo" style="max-height: 50px;"> </a> <a class="navbar-burger" role="button" aria-label="menu" aria-expanded="false" data-target="navMenu"> <span aria-hidden="true"></span> <span aria-hidden="true"></span> <span aria-hidden="true"></span> <span aria-hidden="true"></span> </a></div><!-- children of navbar-menu must be navbar-start and/or navbar-end --><div class="navbar-menu" id="navMenu"><div class="navbar-start"> <!-- navbar items --></div><div class="navbar-end"> <a class="navbar-item" href="https://solaissecurity.com/#services">SERVICES</a> <a class="navbar-item" href="https://solaissecurity.com/#about">ABOUT</a> <a class="navbar-item" href="https://solaissecurity.com/#contact">CONTACT</a> <a class="navbar-item " href="https://solaissecurity.com/blog">BLOG </a><div class="navbar-item has-dropdown is-hoverable"> <a class="navbar-link"> MORE </a><div class="navbar-dropdown is-right"> <a href="https://solaissecurity.com/baseline-assessment/" class="navbar-item is-link "> Baseline Security Assessment </a> <a href="https://solaissecurity.com/security-strategy/" class="navbar-item is-link "> Security Strategy Development </a> <a href="https://solaissecurity.com/control-implementation/" class="navbar-item is-link "> Control Design & Implementation </a> <a href="https://solaissecurity.com/general-consultancy/" class="navbar-item is-link "> Expert at Hand </a> <a href="https://solaissecurity.com/security-review/" class="navbar-item is-link "> Technical Security Review </a> <!--<hr class="navbar-divider"> <a class="navbar-item"> Report an issue </a> --></div></div></div></div></nav><!-- Bulma Navbar JS --> <script> document.addEventListener('DOMContentLoaded', ()=> { /* Get all "navbar-burger" elements */ var $navbarBurgers = Array.prototype.slice.call(document.querySelectorAll('.navbar-burger'), 0); /* Check if there are any navbar burgers */ if ($navbarBurgers.length > 0) { /* Add a click event on each of them */ $navbarBurgers.forEach(el => { el.addEventListener('click', function () { /* Get the target from the "data-target" attribute */ var target = el.dataset.target; var $target = document.getElementById(target); /* Toggle the class on both the "navbar-burger" and the "navbar-menu" */ el.classList.toggle('is-active'); $target.classList.toggle('is-active'); }); }); } }); </script><section class="hero is-fullheight has-text-centered" id="post"><div class="hero-body"><div class="container"> <a href="/blog/commit-signing-overview" class="has-text-black" id="title"><h1 class="title has-text-centered is-2 has-text-weight-semibold ">Commit Signing - Is it worth it?</h1></a><hr class="has-background-black"><div class="columns is-variable is-5"><div class="column is-6"><figure class="image is-16by9 has-shadow"> <img src="https://solaissecurity.com/assets/images/blog/anonymous-commits.png" alt="" id="post-image"></figure></div><div class="subtitle column is-5 has-text-left-desktop has-text-left-fullhd has-text-left-tablet has-text-center-mobile"><p id="description" class="content is-small has-text-weight-medium is-uppercase">Deep dive into why commit signing is worth it, even when hosted platforms like GitHub have strong authentication controls.</p><p class="subtitle is-6 is-uppercase has-text-weight-normal has-text-black-ter">Published on <b>January 05, 2026</b> by <a href="https://github.com/kvql" target="_blank"><b class="has-text-link"><u>Kevin Quill</u></b> </a></p><p class="subtitle is-uppercase"> <i class="fas fa-tags"></i> <span class="tag is-link">post</span> <span class="tag is-link">security-engineering</span> <span class="tag is-link">supply-chain-security</span> <span class="tag is-link">explanation</span> <span class="tag is-link">code-signing</span></p><p class="subtitle is-uppercase"><i class="fas fa-clock"></i> <b class="has-text-link"> 15 min </b>READ</p></div></div><div class="content has-text-justified-desktop has-text-justified-fullhd has-text-justified has-text-justified-tablet has-text-left-mobile"><h1 id="commit-signing---is-it-worth-it">Commit Signing - Is it worth it?</h1><p>I started the journey of writing this thinking there would be scenarios where platform authentication would be sufficient and signing wouldnâ€™t be worth the effort, but I was focusing on this control only from the code integrity perspective. That original assumption was correct but missed the point of signing in git. Code integrity isnâ€™t the primary problem solved by signing, identity verification is. I just wasnâ€™t aware just how mutable commit and author fields were by design. This is my journey of discovery into commit signing to understand when itâ€™s pragmatic to recommend it.</p><p>This mirrors <a href="https://dlorenc.medium.com/should-you-sign-git-commits-f068b07e1b1f">Dan Lorencâ€™s framing</a> - signing is â€œmaybeâ€ worth it, but â€œprobably for a different reason than you think.â€ The reason isnâ€™t code integrity protection, itâ€™s author attribution.</p><p>Why challenge this general best practice vs others? Implementing signing or any control that requires distributed change in workflow for all your engineers will be expensive/time consuming and use up your good will with those users for other changes. Therefore, I like to be sure what the benefit is and how it outweighs the cost.</p><h2 id="the-co-location-problem">The Co-location Problem</h2><p>This problem is why I initially came at this with the wrong perspective. Looking at below without knowing about the Impersonation problem, you would question if signing is worth the extra effort.</p><p>My original hypothesis stems from this problem: for the most common signing implementations, the signing private key is just a secure as the auth material and hence doesnâ€™t raise the bar for malicious activity.</p><ul><li><strong>Typical setup</strong>: SSH keys and signing keys stored similarly<ul><li><code class="language-plaintext highlighter-rouge">~/.ssh/id_ed25519</code> vs <code class="language-plaintext highlighter-rouge">~/.gnupg/</code> - same filesystem, same user permissions</li><li>An attacker with filesystem access attempts to steal both</li><li><strong>Private key on Hardware tokens canâ€™t be stolen</strong>, but attacker can use them while on machine</li></ul></li></ul><h2 id="the-impersonation-problem">The Impersonation Problem</h2><h3 id="the-author-field-is-trivially-spoofable">The author field is trivially spoofable</h3><p>The <a href="https://some-natalie.dev/blog/git-identity/">fundamental disconnect between git identity and platform identity</a> means git trusts self-attestation. Thereâ€™s no verification - it simply records whatever name and email are configured locally.</p><div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># Spoof author on a single commit</span>
git commit <span class="nt">-m</span> <span class="s2">"Add backdoor"</span> <span class="nt">--author</span><span class="o">=</span><span class="s2">"Linus Torvalds &lt;torvalds@linux-foundation.org&gt;"</span>

<span class="c"># Or set it as default for all future commits</span>
git config user.name <span class="s2">"Linus Torvalds"</span>
git config user.email <span class="s2">"torvalds@linux-foundation.org"</span>
git commit <span class="nt">-m</span> <span class="s2">"Add backdoor"</span>
</code></pre></div></div><p>Anyone who can push code (<strong><em>repo write access</em></strong>) can claim to be anyone in gitâ€™s author field.</p><blockquote><p><strong><em>Enterprise Note:</em></strong><br /> Without signing, verifying who actually made a commit requires cross-referencing platform access logs - which most developers and reviewers canâ€™t access. Vigilant mode surfaces this in the normal workflow where people actually look.</p></blockquote><h4 id="the-vigilant-mode-solution">The vigilant mode solution</h4><p>As mentioned, signing commits without any verification doesnâ€™t provide much value. One platform-provided solution for this is GitHubâ€™s Vigilant mode.</p><ul><li>Enable in <a href="https://docs.github.com/en/authentication/managing-commit-signature-verification/displaying-verification-statuses-for-all-of-your-commits">GitHub settings</a> to show verification status on ALL your commits</li><li>Unsigned commits show as â€œUnverifiedâ€</li><li>Impersonation attempts become visible (spoofed commits wonâ€™t have your signature)</li><li><strong>But</strong>: Requires you to sign commits, otherwise your own commits show as unverified</li></ul><p><strong>Critical point:</strong> Signing without verification is security theatre. The value comes from <a href="https://xebia.com/blog/the-use-or-uselessness-of-signed-commits/">surfacing the â€œunverifiedâ€ signal</a> where people actually look:</p><ul><li><strong>Open source</strong>: Enable vigilant mode personally - your commits show verified, impersonation attempts show unverified</li><li><strong>Enterprise</strong>: Enforce signing org-wide + require vigilant mode for all users - unverified commits become visible anomalies in normal workflow</li></ul><h4 id="the-case-against-and-why-i-disagree">The case against (and why I disagree)</h4><p>Some argue commit signing <a href="https://medium.com/@michael.vittrup.larsen/should-we-sign-git-commits-probably-not-c09ad3c18393">isnâ€™t worth the effort</a> since account compromise still defeats it. This misses the point. Without signing, impersonation requires nothing - just set the author field. With signing <em>+ vigilant mode</em>, impersonation requires account compromise to add a malicious key.</p><p>The bar moves from â€œknow their emailâ€ to â€œcompromise their account.â€ Account compromise is always a risk, but thatâ€™s a separate threat with separate controls.</p><h3 id="function-of-the-different-controls">Function of the Different Controls</h3><p>In summary the different controls perform different functions and solve different problems. Therefore, having one doesnâ€™t make the other redundant.</p><ul><li><strong>platform auth:</strong> pull/push (essentially read/write to hosted code)</li><li><strong>Commit Signing:</strong> commit (provides the ability to verify the stated user)<ul><li><em>Important, signing isnâ€™t a preventative control but enables verification later</em></li></ul></li><li><strong>Vigilant Mode:</strong> verification to show if the commit user isnâ€™t valid based on signature or if the author canâ€™t be validated (essentially any time it doesnâ€™t match committer)</li></ul><h2 id="tldr">TL;DR</h2><p><strong><em>Yes, commit signing is a valuable control if you care about who made a change</em></strong></p><p>You need signed commits to be able to verify committer identity in git and the implementation doesnâ€™t need to be complex, using the same SSH key you use for platform auth could suffice.</p><p>Signing on its own doesnâ€™t fix the impersonation problem, it needs to be paired with verification to highlight issues in the commit signatures or missing signatures (e.g. GitHub Vigilant mode).</p><p><strong><em>See the image below:</em></strong> Without signing, the git log should basically just show anonymous for all committer names/emails.</p><p><img src="../assets/images/blog/anonymous-commits-wide.png" alt="anonymous commits" /></p><blockquote><p><strong><em>Enterprise Note:</em></strong><br /> Enforce signing but donâ€™t worry about developer-level implementation details like SSH key on disk vs hardware-backed signing, unless you have serious code integrity requirements and you have implemented the other simpler controls like code review, branch protection, see rest of post.</p></blockquote><h2 id="the-baseline-what-the-hosting-platforms-already-give-you">The Baseline: What The Hosting Platforms Already Give You</h2><p>Before progressing to looking at code integrity, I think itâ€™s important to have some context on the wider set of controls that are relevant here. Below are the other controls outside of commit signing that are important to the topic of source code integrity in a hosted code platform like GitHub</p><ul><li>Authentication and Authorisation to control read/write access to code repositories</li><li>Branch protection rules<ul><li>e.g. enforcing pull request reviews</li></ul></li><li>Signature verification (e.g., Vigilant Mode)</li><li>Platform audit logs (who pushed what, when)</li></ul><p>All these controls rely on two trust boundaries:</p><ul><li>The developer machine</li><li>The developerâ€™s account within the platformâ€™s authentication system (GitHub/GitLab infrastructure)</li></ul><p>Note: Some platform settings can strengthen the above controls making them harder to tamper with by an idividual or compromised developer account (e.g., re-authentication requirements, token expiration policies configurable in user/org settings, reusable workflows)</p><h2 id="the-code-integrity-question">The Code Integrity Question</h2><p>To come back to my original hypothesis: does code signing add value on top of platform auth for code integrity? The answer is more complex.</p><blockquote><p><strong>TLDR:</strong> Unless you have a very high risk threat model, <strong>and</strong> have already implemented controls like branch protection, code review, etc., using commit signing for code integrity isnâ€™t the most pragmatic choice of control.</p><p><em>Ignoring risk of platform compromise, e.g., GitHub servers breached. If this is in your threat model you should be thinking about independent verification regardless.</em></p></blockquote><p>With the impersonation problem covered by basic signing setups, what implementation, if any, will improve code integrity controls vs platform authentication? This is a topic covered at a high level by <a href="https://blog.palantir.com/how-palantir-secures-source-control-105c49079eae">Palantir blog</a>.</p><p>Why basic signing isnâ€™t enough:</p><ul><li>If an attacker can steal your authentication material, they can steal your signing material</li><li>Without independent verification of signatures, public keys could be updated for the user</li><li>Without attestation or some control to enforce configuration of signing setup, it will drift towards the most convenient setup</li></ul><p><strong>Requirements:</strong></p><p>Below are the requirements which would need to be met to improve code integrity guarantees via code signing. There are 3 aspects to it:</p><ul><li>Key Material</li><li>Configuration Attestation</li><li>Independent Signature Verification</li></ul><p>The <a href="2025-11-30-yubikey-setup-commit-signing">Yubikey Setup</a> described in this post gives more specifics on meeting some of these requirements and will be used as an example. <em>This doesnâ€™t mean other implementations arenâ€™t acceptable if they meet the same requirements or objectives.</em></p><h3 id="key-material">Key Material</h3><p>The example implementation here is using a Yubikey or similar device to generate keys on device and require presence for signing operations. This meets the below requirements:</p><ul><li><strong>Requirement:</strong> Unexportable private key material<ul><li><strong>Objective:</strong> Ensures key material canâ€™t be stolen and used on other unmonitored devices.</li></ul></li><li><strong>Requirement:</strong> Proof of presence (touch policy)<ul><li><strong>Objective:</strong> Reduces time window when malicious activity can happen to when the user is present and performing legitimate signing actions anyway.</li></ul></li></ul><h3 id="configuration-attestation">Configuration Attestation</h3><p>The section below on â€œSecurity Control Degradation Over Timeâ€ explains why point in time implementations canâ€™t be relied upon. Therefore you need to ensure the control meets the same requirements after a year as it did day 1.</p><ul><li><strong>Requirement:</strong> Signing process must provide a way to attest its configuration meets the key material requirements.<ul><li><strong>Objective:</strong> At scale, across all developers you can verify the implementation aligns with your requirements continuously while verifying a commit signature or when accepting new trusted keys for a user.</li></ul></li></ul><blockquote><p><strong><em>Alternatives to hardware keys:</em></strong><br /> This could also follow the approach of Sigstore Fulcio with OIDC integrations with Identity Providers to prove presence and identity and solve the storage problem with short-lived certificates. If you can demonstrate the restrictions on key longevity and access requirements, maybe the same objective can be met without needing hardware.</p></blockquote><p>Yubikey Example: A Yubikey signed certificate is generated on device which can be exported and used to verify the private key signing commits and its associated touch policy configuration align with your requirements. This can be validated when accepting a new trusted public key.</p><h3 id="independent-verification">Independent Verification</h3><p>In order to solve the risk of GitHub signed web commits, devâ€™s platform account compromise, configuration attestation, etc., there has to be a process to verify the commit signatures against a central trust store.</p><ul><li><strong>Requirement:</strong> If a userâ€™s account within the code hosting platform (e.g., GitHub) is compromised, that access canâ€™t be used to change that userâ€™s trusted public key (e.g., used for verification)<ul><li><strong>Objective:</strong> Provide independence to remove the userâ€™s platform account as a single point of failure</li></ul></li><li><strong>Requirement:</strong> Commit signature or trusted public key are verified to ensure they align with configuration attestation<ul><li><strong>Objective:</strong> Commit signatures canâ€™t pass verification if the way they have been signed canâ€™t be validated</li></ul></li></ul><h3 id="threat-scenarios-by-implementation">Threat Scenarios by Implementation</h3><p>This section will review the different controls and their effectiveness against threats to code integrity. The two tables will demonstrate the impact of â€œConfiguration Attestationâ€ and why itâ€™s required.</p><h4 id="with-configuration-attestation-ideal-state">With Configuration Attestation (Ideal State)</h4><table><thead><tr><th style="text-align: left">Threat Scenario</th><th style="text-align: left">Platform Auth</th><th style="text-align: left">Software Signing</th><th style="text-align: left">Platform Signature Verification (vigilant mode)</th><th style="text-align: left">â€œHardwareâ€ Signing**</th><th style="text-align: left">Independent signature Verification</th></tr></thead><tbody><tr><td style="text-align: left">Author impersonation</td><td style="text-align: left">ğŸš« commit and author spoofable</td><td style="text-align: left">âœ… shows unverified</td><td style="text-align: left">âœ… shows unsigned</td><td style="text-align: left">âœ… Vigilant mode shows unsigned</td><td style="text-align: left">âœ… Verification fails</td></tr><tr><td style="text-align: left">Stolen GitHub token/session (push web commit)</td><td style="text-align: left">ğŸš« Already compromised</td><td style="text-align: left">ğŸš« Web commits signed by GitHub</td><td style="text-align: left">ğŸš« Web commits signed by GitHub</td><td style="text-align: left">ğŸš« Web commits signed by GitHub</td><td style="text-align: left">âœ… Production changes blocked</td></tr><tr><td style="text-align: left">Platform or Platform admin compromise</td><td style="text-align: left">ğŸš« Relies on platform controls</td><td style="text-align: left">ğŸš« Relies on platform controls</td><td style="text-align: left">ğŸš« Relies on platform controls</td><td style="text-align: left">ğŸš« Relies on platform controls</td><td style="text-align: left">âœ… prevents single point of failure</td></tr><tr><td style="text-align: left">Compromised developer machine (key material stolen)</td><td style="text-align: left">ğŸš« Auth material stolen</td><td style="text-align: left">ğŸš« Signing key also stolen</td><td style="text-align: left">ğŸš« Relies on secure signing key</td><td style="text-align: left">âœ… canâ€™t be extracted from hardware token, Attacker forced to stay on device</td><td style="text-align: left">N/A</td></tr><tr><td style="text-align: left">Compromised developer machine (code injected to legitimate commit)</td><td style="text-align: left">ğŸš« Auth material stolen</td><td style="text-align: left">ğŸš« Signing key also stolen</td><td style="text-align: left">ğŸš« Relies on secure signing key</td><td style="text-align: left">âš ï¸ Attacker forced to stay on device (no prevention, increased chance of detection)</td><td style="text-align: left">ğŸš« Verification will pass as code signed along with legitimate commit</td></tr></tbody></table><blockquote><p><strong><em>There are No Perfect Controls:</em></strong><br /> As you can see in both tables, even with the ideal setup, there are still attack vectors to sign a malicious commit. However, if paired with strong endpoint monitoring or controls like code review, these controls significantly improve your chance of detecting a malicious action. This is discussed more in <a href="https://blog.palantir.com/how-palantir-secures-source-control-105c49079eae">Palantir blog</a>.</p></blockquote><h4 id="without-configuration-attestation-reality-over-time">Without Configuration Attestation (Reality Over Time)</h4><table><thead><tr><th style="text-align: left">Threat Scenario</th><th style="text-align: left">Platform Auth</th><th style="text-align: left">Software Signing</th><th style="text-align: left">Platform Signature Verification (vigilant mode)</th><th style="text-align: left">â€œHardwareâ€ Signing**</th><th style="text-align: left">Independent signature Verification</th></tr></thead><tbody><tr><td style="text-align: left">Compromised developer machine (key material stolen)</td><td style="text-align: left">ğŸš« Auth material stolen</td><td style="text-align: left">ğŸš« Signing key also stolen</td><td style="text-align: left">ğŸš« Relies on secure signing key</td><td style="text-align: left">ğŸš« control drift, Likely accessible</td><td style="text-align: left">N/A</td></tr><tr><td style="text-align: left">Compromised developer machine (code injected to legitimate commit)</td><td style="text-align: left">ğŸš« Auth material stolen</td><td style="text-align: left">ğŸš« Signing key also stolen</td><td style="text-align: left">ğŸš« Relies on secure signing key</td><td style="text-align: left">ğŸš« control drift, Likely accessible</td><td style="text-align: left">ğŸš« Verification will pass as code signed along with legitimate commit</td></tr></tbody></table><h4 id="control-drift---common-most-convenient-setup-shortcuts">Control Drift - Common â€œmost convenient setupâ€ shortcuts</h4><ul><li>Generating keys on laptop then importing to hardware token (defeats the purpose)</li><li>Backing up hardware-generated keys to disk â€œjust in caseâ€</li><li>Not enforcing touch policy</li><li>Exporting keys to multiple tokens without proper key ceremonies</li></ul><p><strong>The gap</strong>: The difference between â€œIdeal Stateâ€ and â€œReality Over Timeâ€ is entirely about enforcement. Without technical controls that verify proper setup and perform external verification, you get degraded behavior over time.</p><h3 id="why-hardware-signing-helps-when-done-right">Why Hardware Signing Helps (When Done Right)</h3><ul><li><strong>Forces attacker persistence</strong>: Canâ€™t exfiltrate key, must stay on machine to sign</li><li><strong>Increases detection window</strong>: More time for monitoring/EDR to catch malicious activity</li><li><strong>Touch policy adds friction</strong>: Even cached-fixed requires periodic physical access and forces the attacker to time changes with legitimate activity, again increasing detection window.</li><li><strong>But</strong>: Only works if you can continuously verify keys were generated on-device and remain properly configured (attestation + ongoing verification)</li></ul><h2 id="security-control-degradation-over-time">Security Control Degradation Over Time</h2><h3 id="initial-rollout-month-1-3">Initial rollout (Month 1-3)</h3><ul><li>Engineers follow secure setup procedures</li><li>Hardware tokens properly configured</li><li>Keys generated on-device, touch policies set</li><li>High compliance with security guidance</li></ul><h3 id="reality-after-6-12-months">Reality after 6-12 months</h3><ul><li>New laptop setup â†’ â€œIâ€™ll just import my backup key this onceâ€</li><li>Lost/forgotten hardware token â†’ â€œIâ€™ll generate a new key on disk temporarilyâ€</li><li>Frustration with touch policy during rebases â†’ switched to longer cache or disabled</li><li>New team members follow examples from existing codebases/wikis that show convenient patterns</li><li><strong>Critical mass shift</strong>: Once enough engineers use convenient workarounds, it becomes the de facto standard</li></ul><h3 id="why-this-happens-not-a-criticism">Why this happens (not a criticism)</h3><ul><li>Legitimate friction accumulates: lost tokens, laptop replacements, travel without token</li><li>No immediate feedback when taking shortcuts (signing still works)</li><li>Peer examples normalize workarounds (â€œeveryone does it this wayâ€)</li><li>Toil builds up over hundreds of commits per month</li><li>Security team isnâ€™t notified when engineers modify their setup</li></ul><h3 id="the-enforcement-gap">The enforcement gap</h3><ul><li>Without technical controls that verify proper setup (e.g. attestation), you have <strong>no visibility</strong> into this drift</li><li>â€œIdeal Stateâ€ â†’ â€œReality Over Timeâ€ transition happens silently</li><li>By the time the security value has degraded, the implementation cost has already been paid</li></ul><p>This is why the â€œConfiguration Attestationâ€ requirement is so key to ensure the investment in independent verification and hardware keys stays valuable long term.</p><h2 id="conclusion">Conclusion</h2><p><strong>The misconception</strong>: Commit signing prevents malicious code from reaching production.</p><p><strong>The reality</strong>: Signing solves identity, not integrity. Gitâ€™s author field is trivially spoofable; signing is the only way to verify who actually made a commit.</p><p><strong>Practical recommendations:</strong></p><ul><li><strong>For most teams</strong>: Enable signing with your existing SSH key + vigilant mode. If on-disk SSH keys are acceptable for authentication, theyâ€™re acceptable for signing. This solves impersonation.</li><li><strong>For code integrity</strong>: Hardware keys alone donâ€™t get you much <strong>at scale</strong>. You need the full stack: hardware-backed keys + configuration attestation + independent signature verification. Without attestation, implementations drift toward convenience and youâ€™re back to software signing within a year. Accept this operational overhead only if youâ€™ve already implemented code review and branch protection, and have genuine supply chain concerns.</li></ul><p>Donâ€™t let perfect be the enemy of good. Basic signing with vigilant mode is a significant improvement over platform auth alone, where anyone with push access can claim to be anyone.</p><blockquote><p><strong><em>Future direction:</em></strong><br /> The <a href="https://some-natalie.dev/blog/git-identity/">fundamental identity gap in git</a> wonâ€™t be solved by hardware tokens alone. OIDC-based signing (like Sigstoreâ€™s Fulcio) ties short-lived certificates to your identity provider, eliminating long-lived key management entirely. The requirement that doesnâ€™t change: enforcement and verification.</p></blockquote></div><div class="disqus-comments" id="disqus_thread"></div></div></div></section><footer class="footer has-background-primary-dark has-text-primary-light" data-theme="dark"> <!--Footer Button--><div class="container has-text-centered " id="backtotop"> <a class="footer-btn" onclick="window.scroll(0,0)">BACK TO TOP</a></div><!--Footer Main Section--><div><div class="columns"> <!--Name Section--><div class="column has-text-left-desktop has-text-centere-mobile"><div class="columns"><div class="column is-one-fifth-desktop is-one-fifth-fullhd is-one-quarter-tablet is-flex has-text-centered"><figure class="image is-64x64 has-text-centered"> <img class="is-rounded" src="https://solaissecurity.com/assets/images/logo.png"></figure></div><div class="column is-marginless has-text-left-desktop has-text-centere-mobile"><h3 class="has-text-weight-bold has-text-centered has-text-primary-light">Solais Security</h3><a href="https://solaissecurity.com/#about"><div class="content"><p>Solais Security is an independent security consultancy run by Kevin Quil...</p></div></a></div></div></div><!--Link Section--><div class="column"><h3 class="has-text-weight-bold has-text-centered has-text-primary-light">More Links</h3><li> <a target="_blank" href="https://solaissecurity.com/#contact">Contact Us</a></li><li> <a target="_blank" href="https://solaissecurity.com/services">Services</a></li><!--<li> <a target="_blank" href="https://solaissecurity.com/feed.xml">Subscribe via RSS</a></li>--></div><!--Blog-post Section--><div class="column"><h3 class="has-text-weight-bold has-text-centered has-text-primary-light">Recent Posts</h3><li> <a href="https://solaissecurity.com/blog/commit-signing-overview"> Commit Signing - Is it worth it?</a></li><li> <a href="https://solaissecurity.com/blog/yubikey-setup-commit-signing"> Setting Up Git Commit Signing with Multiple Yub...</a></li><li> <a href="https://solaissecurity.com/blog/seceng-part-2"> Navigating the Role of an Embedded Security Eng...</a></li></div></div></div><!--<div class="has-background-black has-text-centered has-text-white" id="credits"> <i class="far fa-copyright"></i> 2026 | <a href="https://github.com/thedevslot/WhatATheme" target="_blank" rel="noopener noreferrer">WhatATheme</a> - A Theme made with <i class="fas fa-heart has-text-danger"></i> by <a href="https://www.twitter.com/thedevslot" target="_blank" rel="noopener noreferrer">TheDevsLot</a> Powered by <a href="https://jekyllrb.com/" target="_blank">Jekyll</a></div>--></footer></body><script> /** * RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS. * LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/ /* var disqus_config = function () { this.page.url = PAGE_URL; Replace PAGE_URL with your page's canonical URL variable this.page.identifier = PAGE_IDENTIFIER; Replace PAGE_IDENTIFIER with your page's unique identifier variable }; */ (function () { /* DON'T EDIT BELOW THIS LINE */ var d = document, s = d.createElement('script'); s.src = 'https://.disqus.com/embed.js'; s.setAttribute('data-timestamp', +new Date()); (d.head || d.body).appendChild(s); })(); </script></html>
